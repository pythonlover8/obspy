"""
obspy.core.event.resource_id - ResourceIdentifier and Friends
=============================================================
This module defines the ResourceIdentifier class and associated code.
"""

from __future__ import (absolute_import, division, print_function,
                        unicode_literals)
from future.builtins import *  # NOQA
from future.utils import native_str

import collections
import inspect
import re
import warnings
import weakref
from contextlib import contextmanager
from copy import deepcopy
from uuid import uuid4


class _ResourceSingleton(object):
    """
    A private singleton class used to refer id strings to objects.

    This class allows python gc to handle cleanup of the
    _resource_id_weak_dict attribute of the ResourceIdentifier rather than
    manual (and brittle) reference counting.
    """
    # define a mapping from a resource string to a singleton instance
    _str2singleton = weakref.WeakValueDictionary()

    def __new__(cls, id_str):
        try:
            return cls._str2singleton[id_str]
        except KeyError:
            return super(_ResourceSingleton, cls).__new__(cls)

    def __init__(self, id_str):
        self.id_str = id_str
        # add instance to class dict
        self.__class__._str2singleton[id_str] = self

    def __hash__(self):
        return hash(self.id_str) + hash('_ResourceSingleton')

    def __str__(self):
        return self.id_str

    def __repr__(self):
        return self.id_str

    def __deepcopy__(self, memodict={}):
        memodict[id(self)] = self
        return self

    def __copy__(self):
        return self


class ResourceIdentifier(object):
    """
    Unique identifier of any resource so it can be referred to.
    In QuakeML many elements and types can have a unique id that other elements
    use to refer to it. This is called a ResourceIdentifier and it is used for
    the same purpose in the obspy.core.event classes.
    In QuakeML it has to be of the following regex form::
        (smi|quakeml):[\w\d][\w\d\-\.\*\(\)_~']{2,}/[\w\d\-\.\*\(\)_~']
        [\w\d\-\.\*\(\)\+\?_~'=,;#/&amp;]*
    e.g.
    * ``smi:sub.website.org/event/12345678``
    * ``quakeml:google.org/pick/unique_pick_id``
    smi stands for "seismological meta-information".
    In this class it can be any hashable object, e.g. most immutable objects
    like numbers and strings.
    :type id: str, optional
    :param id: A unique identifier of the element it refers to. It is
        not verified, that it actually is unique. The user has to take care of
        that. If no resource_id is given, uuid.uuid4() will be used to
        create one which assures uniqueness within one Python run.
        If no fixed id is provided, the ID will be built from prefix
        and a random uuid hash. The random hash part can be regenerated by the
        referred object automatically if it gets changed.
    :type prefix: str, optional
    :param prefix: An optional identifier that will be put in front of any
        automatically created resource id. The prefix will only have an effect
        if `id` is not specified (for a fixed ID string). Makes automatically
        generated resource ids more reasonable. By default "smi:local" is used
        which ensures a QuakeML conform resource identifier.
    :type referred_object: Python object, optional
    :param referred_object: The object this instance refers to. All instances
        created with the same resource_id will be able to access the object as
        long as at least one instance actually has a reference to it.
        Additionally, ResourceIdentifier instances that have the same id but
        different referred_objects will still return the referred object,
        provided it doesn't get garbage collected. If the referred object no
        longer exists any object with the same id will be returned.
    .. rubric:: General Usage
    >>> ResourceIdentifier('2012-04-11--385392')
    ResourceIdentifier(id="2012-04-11--385392")
    >>> # If 'id' is not specified it will be generated automatically.
    >>> ResourceIdentifier()  # doctest: +ELLIPSIS
    ResourceIdentifier(id="smi:local/...")
    >>> # Supplying a prefix will simply prefix the automatically generated ID
    >>> ResourceIdentifier(prefix='event')  # doctest: +ELLIPSIS
    ResourceIdentifier(id="event/...")
    ResourceIdentifiers can, and oftentimes should, carry a reference to the
    object they refer to. This is a weak reference which means that if the
    object get deleted or runs out of scope, e.g. gets garbage collected, the
    reference will cease to exist.
    >>> from obspy.core.event import Event
    >>> event = Event()
    >>> import sys
    >>> ref_count = sys.getrefcount(event)
    >>> res_id = ResourceIdentifier(referred_object=event)
    >>> # The reference does not changed the reference count of the object.
    >>> print(ref_count == sys.getrefcount(event))
    True
    >>> # It actually is the same object.
    >>> print(event is res_id.get_referred_object())
    True
    >>> # Deleting it, or letting the garbage collector handle the object will
    >>> # invalidate the reference.
    >>> del event
    >>> print(res_id.get_referred_object())  # doctest: +SKIP
    None
    The most powerful ability (and reason why one would want to use a resource
    identifier class in the first place) is that once a ResourceIdentifier with
    an attached referred object has been created, any other ResourceIdentifier
    instances with the same ID can retrieve that object. This works
    across all ResourceIdentifiers that have been instantiated within one
    Python run.
    This enables, e.g. the resource references between the different QuakeML
    elements to work in a rather natural way.
    >>> event_object = Event()
    >>> obj_id = id(event_object)
    >>> res_id = "obspy.org/event/test"
    >>> ref_a = ResourceIdentifier(res_id)
    >>> # The object is refers to cannot be found yet. Because no instance that
    >>> # an attached object has been created so far.
    >>> print(ref_a.get_referred_object())
    None
    >>> # This instance has an attached object.
    >>> ref_b = ResourceIdentifier(res_id, referred_object=event_object)
    >>> ref_c = ResourceIdentifier(res_id)
    >>> # All ResourceIdentifiers will refer to the same object.
    >>> assert(id(ref_a.get_referred_object()) == obj_id)
    >>> assert(id(ref_b.get_referred_object()) == obj_id)
    >>> assert(id(ref_c.get_referred_object()) == obj_id)
    Resource identifiers are bound to an object once the get_referred_object
    method has been called. The results is that  get_referred_object will
    always return the same object it did on the first call as long as the
    object still exists. If the bound object gets garage collected a warning
    will be issued and another object with the same resource_id will be
    returned if one exists. If no other object has the same resource_id, an
    additional warning will be issued and None returned.
    >>> res_id = 'obspy.org/tests/test_resource_doc_example'
    >>> obj_a = UTCDateTime(10)
    >>> obj_b = UTCDateTime(10)
    >>> ref_a = ResourceIdentifier(res_id, referred_object=obj_a)
    >>> ref_b = ResourceIdentifier(res_id, referred_object=obj_b)
    >>> assert ref_a.get_referred_object() == ref_b.get_referred_object()
    >>> assert ref_a.get_referred_object() is not ref_b.get_referred_object()
    >>> assert ref_a.get_referred_object() is obj_a
    >>> assert ref_b.get_referred_object() is obj_b
    >>> del obj_b  # if obj_b gets garbage collected
    >>> assert ref_b.get_referred_object() is obj_a  # doctest: +SKIP
    >>> del obj_a  # now no object with res_id exists
    >>> assert ref_b.get_referred_object() is None  # doctest: +SKIP
    The id can be converted to a valid QuakeML ResourceIdentifier by calling
    the convert_id_to_quakeml_uri() method. The resulting id will be of the
    form::
        smi:authority_id/prefix/id
    >>> res_id = ResourceIdentifier(prefix='origin')
    >>> res_id.convert_id_to_quakeml_uri(authority_id="obspy.org")
    >>> res_id  # doctest: +ELLIPSIS
    ResourceIdentifier(id="smi:obspy.org/origin/...")
    >>> res_id = ResourceIdentifier(id='foo')
    >>> res_id.convert_id_to_quakeml_uri()
    >>> res_id
    ResourceIdentifier(id="smi:local/foo")
    >>> # A good way to create a QuakeML compatibly ResourceIdentifier from
    >>> # scratch is
    >>> res_id = ResourceIdentifier(prefix='pick')
    >>> res_id.convert_id_to_quakeml_uri(authority_id='obspy.org')
    >>> res_id  # doctest: +ELLIPSIS
    ResourceIdentifier(id="smi:obspy.org/pick/...")
    >>> # If the given ID is already a valid QuakeML
    >>> # ResourceIdentifier, nothing will happen.
    >>> res_id = ResourceIdentifier('smi:test.org/subdir/id')
    >>> res_id
    ResourceIdentifier(id="smi:test.org/subdir/id")
    >>> res_id.convert_id_to_quakeml_uri()
    >>> res_id
    ResourceIdentifier(id="smi:test.org/subdir/id")
    ResourceIdentifiers are considered identical if the IDs are
    the same.
    >>> # Create two different resource identifiers.
    >>> res_id_1 = ResourceIdentifier()
    >>> res_id_2 = ResourceIdentifier()
    >>> assert(res_id_1 != res_id_2)
    >>> # Equalize the IDs. NEVER do this. This just an example.
    >>> res_id_2.id = res_id_1.id = "smi:local/abcde"
    >>> assert(res_id_1 == res_id_2)
    ResourceIdentifier instances can be used as dictionary keys.
    >>> dictionary = {}
    >>> res_id = ResourceIdentifier(id="foo")
    >>> dictionary[res_id] = "bar1"
    >>> # The same ID can still be used as a key.
    >>> dictionary["foo"] = "bar2"
    >>> items = sorted(dictionary.items(), key=lambda kv: kv[1])
    >>> for k, v in items:  # doctest: +ELLIPSIS
    ...     print(repr(k), v)
    ResourceIdentifier(id="foo") bar1
    ...'foo' bar2
    """
    # Class (not instance) attribute that keeps track of all resource
    # identifier throughout one Python run. Will only store weak references
    # and therefore does not interfere with the garbage collection.
    # DO NOT CHANGE THIS FROM OUTSIDE THE CLASS.
    # a nested dict with _ResourceSingletons as keys, and default dicts with
    # ids as keys and weakrefs as values.
    __resource_id_weak_dict = weakref.WeakKeyDictionary()
    # Use an additional dictionary to track all resource ids.
    # __resource_id_tracker = collections.defaultdict(int)
    # yet another dictionary for keep track of resources id that are not bound.
    # keys are the id and values are a weak ref to the resource identifier.
    __unbound_resource_id = weakref.WeakValueDictionary()

    def __init__(self, id=None, prefix="smi:local",
                 referred_object=None):
        # Create a resource id if None is given and possibly use a prefix.
        if id is None:
            self.fixed = False
            self._prefix = prefix
            self._uuid = str(uuid4())
        elif isinstance(id, ResourceIdentifier):
            self.__dict__.update(id.__dict__)
            return
        else:
            self.fixed = True
            self.id = id
        # get resource singleton
        self._id_key = _ResourceSingleton(self.id)

        # Append the referred object in case one is given to the class level
        # reference dictionary.
        self._object_id = None  # the object specific ID
        if referred_object is not None:
            self.set_referred_object(referred_object)

    @classmethod
    def print_state(cls):
        """
        Print the current resource_id state, very useful for debugging
        """
        from pprint import pprint
        print('-' * 79)
        print('resource_dict:')
        pprint(dict(cls.__resource_id_weak_dict))
        print('-' * 79)
        print('unbound:')
        pprint(dict(cls.__unbound_resource_id))
        print('-' * 79)

    @classmethod
    def bind_resource_ids(cls):
        """
        Bind the unbound ResourceIdentifier instances to referred objects.
        Binds all of the unbound ResourceIdentifier instances to the most
        recent object assigned to the resource_id. This ensures that all
        resource identifiers will return the same object they are bound to
        until the object goes out of scope.
        """
        for rid_id in list(cls.__unbound_resource_id):
            rid = cls.__unbound_resource_id.pop(rid_id, None)
            if rid is not None:  # if the resource id still exists
                rid.get_referred_object()  # will bind rid to referred object

    def get_referred_object(self):
        """
        Returns the object associated with the resource identifier.
        This works as long as at least one ResourceIdentifier with the same
        ID as this instance has an associate object.
        Will return None if no object could be found.
        """
        try:
            rdic = ResourceIdentifier.__resource_id_weak_dict[self._id_key]
        except KeyError:
            return None
        else:
            if self._object_id in rdic and rdic[self._object_id]() is not None:
                return rdic[self._object_id]()
            else:  # find last added obj that is not None
                return self._get_similar_referred_object()

    def _get_similar_referred_object(self):
        """
        Find an object with the same resource_id that is not None and
        return it. Also pop all keys that have None values in the
        __resource_id_weak_dict
        """
        rdic = ResourceIdentifier.__resource_id_weak_dict[self._id_key]
        if self._object_id is not None:
            msg = ("The object with identity of: %d no longer exists, "
                   "returning the most recently created object with a"
                   " resource id of: %s") % (self._object_id, self.id)
            line_number = inspect.currentframe().f_back.f_lineno
            warnings.warn_explicit(msg, UserWarning, __file__,
                                   line_number)
            self._object_id = None  # reset object id
        # find a obj that is not None starting at last in ordered dict
        for key in list(reversed(rdic)):
            obj = rdic[key]()
            if obj is not None:
                self.set_referred_object(obj)
                return obj
            else:  # remove references that are None
                rdic.pop(key)
        else:  # if iter runs out all objects are none; pop rid, return None
            ResourceIdentifier.__resource_id_weak_dict.pop(self._id_key)
            msg = ('no object found with resource id %s, returning None'
                   % self.id)
            line_number = inspect.currentframe().f_back.f_lineno
            warnings.warn_explicit(msg, UserWarning, __file__, line_number)
            return None

    def set_referred_object(self, referred_object, warn=True):
        """
        Binds a ResourceIdentifier instance to an object.
        If it already a weak reference it will be used, otherwise one will be
        created. If the object is None, None will be set.
        Will also append self again to the global class level reference list
        so everything stays consistent. Warning can be ignored by setting
        the warn parameter to False.
        """
        self._object_id = id(referred_object)  # identity of object
        rdic = ResourceIdentifier.__resource_id_weak_dict
        # if the resource_id is in the rid_dict but object_id is not
        if self._id_key in rdic and self._object_id not in rdic[self._id_key]:
            # get the most recently defined object with this id
            object_dict = rdic[self._id_key]
            object_list = list(object_dict.values())
            last_obj = next(reversed(object_list))()
            if warn and last_obj is not None and last_obj != referred_object:
                msg = ('Warning, binding object to resource ID %s which '
                       'is not equal to the last object bound to this '
                       'resource_id') % self.id
                line_number = inspect.currentframe().f_back.f_lineno
                warnings.warn_explicit(msg, UserWarning, __file__,
                                       line_number)
            rdic[self._id_key][self._object_id] = weakref.ref(referred_object)
        # if there is no entry for the id key yet make one
        elif self._id_key not in rdic:
            rdic[self._id_key] = collections.OrderedDict()
            rdic[self._id_key][self._object_id] = weakref.ref(referred_object)

    def convert_id_to_quakeml_uri(self, authority_id="local"):
        """
        Converts the current ID to a valid QuakeML URI.
        Only an invalid QuakeML ResourceIdentifier string it will be converted
        to a valid one.  Otherwise nothing will happen but after calling this
        method the user can be sure that the ID is a valid QuakeML URI.
        The resulting ID will be of the form
            smi:authority_id/prefix/resource_id
        :type authority_id: str, optional
        :param authority_id: The base url of the resulting string. Defaults to
            ``"local"``.
        """
        self.id = self.get_quakeml_uri(authority_id=authority_id)

    def get_quakeml_uri(self, authority_id="local"):
        """
        Returns the ID as a valid QuakeML URI if possible. Does not
        change the ID itself.
        >>> res_id = ResourceIdentifier("some_id")
        >>> print(res_id.get_quakeml_uri())
        smi:local/some_id
        >>> # Did not change the actual resource id.
        >>> print(res_id.id)
        some_id
        """
        id = self.id
        if str(id).strip() == "":
            id = str(uuid4())

        regex = r"^(smi|quakeml):[\w\d][\w\d\-\.\*\(\)_~']{2,}/[\w\d\-\." + \
                r"\*\(\)_~'][\w\d\-\.\*\(\)\+\?_~'=,;#/&amp;]*$"
        result = re.match(regex, str(id))
        if result is not None:
            return id
        id = 'smi:%s/%s' % (authority_id, str(id))
        # Check once again just to be sure no weird symbols are stored in the
        # ID.
        result = re.match(regex, id)
        if result is None:
            msg = (
                "The id '%s' is not a valid QuakeML resource "
                "identifier. ObsPy tried modifying it to '%s' but it is still "
                "not valid. Please make sure all resource ids are either "
                "valid or can be made valid by prefixing them with "
                "'smi:<authority_id>/'. Valid ids are specified in the "
                "QuakeML manual section 3.1 and in particular exclude colons "
                "for the final part." % (self.id, id))
            raise ValueError(msg)
        return id

    def copy(self):
        """
        Returns a copy of the ResourceIdentifier.
        >>> res_id = ResourceIdentifier()
        >>> res_id_2 = res_id.copy()
        >>> print(res_id is res_id_2)
        False
        >>> print(res_id == res_id_2)
        True
        """
        return deepcopy(self)

    def __deepcopy__(self, memodict={}):
        new = ResourceIdentifier.__new__(ResourceIdentifier)
        new.__dict__.update(self.__dict__)
        # clear object_id upon copying resource_ids
        new._object_id = None
        memodict[id(self)] = new
        return new

    @property
    def _object_id(self):
        return self.__dict__['_object_id']

    @_object_id.setter
    def _object_id(self, value):
        if value is None:  # add instance to unbound dict
            self.__class__.__unbound_resource_id[id(self)] = self
        else:  # binding to object, remove instance from unbound dict
            self.__class__.__unbound_resource_id.pop(id(self), None)
        self.__dict__['_object_id'] = value

    @property
    def id(self):
        """
        Unique identifier of the current instance.
        """
        if self.fixed:
            return self.__dict__.get("id")
        else:
            id = self.prefix
            if not id.endswith("/"):
                id += "/"
            id += self.uuid
            return id

    @id.deleter
    def id(self):
        msg = "The resource id cannot be deleted."
        raise Exception(msg)

    @id.setter
    def id(self, value):
        self.fixed = True
        # XXX: no idea why I had to add bytes for PY2 here
        if not isinstance(value, (str, bytes)):
            msg = "attribute id needs to be a string."
            raise TypeError(msg)
        self.__dict__["id"] = value

    @property
    def prefix(self):
        return self._prefix

    @prefix.deleter
    def prefix(self):
        self._prefix = ""

    @prefix.setter
    def prefix(self, value):
        if not isinstance(value, (str, native_str)):
            msg = "prefix id needs to be a string."
            raise TypeError(msg)
        self._prefix = value

    @property
    def uuid(self):
        return self._uuid

    @uuid.deleter
    def uuid(self):
        """
        Deleting is uuid hash is forbidden and will not work.
        """
        msg = "The uuid cannot be deleted."
        raise Exception(msg)

    @uuid.setter
    def uuid(self, value):  # @UnusedVariable
        """
        Setting is uuid hash is forbidden and will not work.
        """
        msg = "The uuid cannot be set manually."
        raise Exception(msg)

    @property
    def resource_id(self):
        return self.id

    @resource_id.deleter
    def resource_id(self):
        del self.id

    @resource_id.setter
    def resource_id(self, value):
        self.id = value

    def __str__(self):
        return self.id

    def _repr_pretty_(self, p, cycle):
        p.text(str(self))

    def __repr__(self):
        return 'ResourceIdentifier(id="%s")' % self.id

    def __eq__(self, other):
        if self.id == other:
            return True
        if not isinstance(other, ResourceIdentifier):
            return False
        if self.id == other.id:
            return True
        return False

    def __ne__(self, other):
        return not self.__eq__(other)

    def __hash__(self):
        """
        Uses the same hash as the resource id. This means that class instances
        can be used in dictionaries and other hashed types.
        Both the object and it's id can still be independently used as
        dictionary keys.
        """
        # "Salt" the hash with a string so the hash of the object and a
        # string identical to the id can both be used as individual
        # dictionary keys.
        return hash("RESOURCE_ID") + self.id.__hash__()

    def regenerate_uuid(self):
        """
        Regenerates the uuid part of the ID. Does nothing for resource
        identifiers with a user-set, fixed id.
        """
        self._uuid = str(uuid4())

    @classmethod
    def _bind_class_state(cls, state_dict):
        """
        Bind the state contained in state_dict to ResourceIdentifier class.
        """
        cls.__resource_id_weak_dict = state_dict['rdict']
        cls.__unbound_resource_id = state_dict['unbound']

    @classmethod
    @contextmanager
    def _debug_class_state(cls):
        """
        Context manager for debugging the class level state for Resource Ids.

        Replaces the current resource_id and unbound mappings returning
        a dictionary with the new mappings as values and "rdict", and
        "unbound" as keys. This function restores original mappings upon exit.
        """
        # get current class state
        old_state = dict(
            rdict=cls.__resource_id_weak_dict,
            unbound=cls.__unbound_resource_id,
        )
        # init new class state
        new_state = dict(
            rdict=weakref.WeakKeyDictionary(),
            unbound=weakref.WeakValueDictionary(),
        )
        # bind new state and return dict
        cls._bind_class_state(new_state)
        yield new_state
        # reset prior state
        cls._bind_class_state(old_state)
